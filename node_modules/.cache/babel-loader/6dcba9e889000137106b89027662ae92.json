{"ast":null,"code":"/**\n * Validate using the validatorjs library as a strategy for react-validation-mixin\n *\n * @see https://github.com/skaterdav85/validatorjs\n * @see https://jurassix.gitbooks.io/docs-react-validation-mixin/content/overview/strategies.html\n */\n'use strict';\n\nvar Validator = require('validatorjs');\n\nmodule.exports = {\n  /**\n   * Used to create this.validatorTypes in a React component and to be passed to validate or validateServer\n   *\n   * @param {Object} rules List of rules as specified by validatorjs\n   * @param {Object} messages Optional list of custom messages as specified by validatorjs\n   * @param {Function} callback if specified, called to allow customisation of validator\n   * @returns {Object}\n   */\n  createSchema: function createSchema(rules, messages, callback) {\n    return {\n      rules: rules,\n      messages: messages,\n      callback: callback\n    };\n  },\n\n  /**\n   * Same as createSchema, but the rules are disabled until activateRule is called\n   *\n   * @param {Object} rules List of rules as specified by validatorjs\n   * @param {Object} messages Optional list of custom messages as specified by validatorjs\n   * @param {Function} callback if specified, called to allow customisation of validator\n   * @returns {Object}\n   */\n  createInactiveSchema: function createInactiveSchema(rules, messages, callback) {\n    var schema = this.createSchema(rules, messages, callback);\n    schema.activeRules = [];\n    return schema;\n  },\n\n  /**\n   * Active a specific rule\n   *\n   * @param {Object} schema As created by createInactiveSchema\n   * @param {Object} rule Name of the rule as a key in schema.rules\n   */\n  activateRule: function activateRule(schema, rule) {\n    if (typeof schema.activeRules !== 'undefined' && schema.activeRules.indexOf(rule) === -1) {\n      schema.activeRules.push(rule);\n    }\n  },\n\n  /**\n   * Create a validator from submitted data and a schema\n   *\n   * @param {Object} data The data submitted\n   * @param {Object} schema Contains rules and custom error messages\n   * @param {Boolean} forceActive Whether to force all rules to be active even if not activated\n   * @returns {Validator}\n   */\n  createValidator: function createValidator(data, schema, forceActive) {\n    var rules = {}; // Only add active rules to the validator if an initially inactive schema has been created.\n\n    if (typeof schema.activeRules !== 'undefined') {\n      // Force all rules to be active if specified\n      if (forceActive) {\n        schema.activeRules = Object.keys(schema.rules);\n      }\n\n      for (var i in schema.activeRules) {\n        var ruleName = schema.activeRules[i];\n        rules[ruleName] = schema.rules[ruleName];\n      }\n    } else {\n      rules = schema.rules;\n    }\n\n    var validator = new Validator(data, rules, schema.messages); // If a callback has been specified on the schema, call it to allow customisation of the validator\n\n    if (typeof schema.callback === 'function') {\n      schema.callback(validator);\n    }\n\n    return validator;\n  },\n\n  /**\n   * Called by react-validation-mixin\n   *\n   * @param {Object} data The data submitted\n   * @param {Object} schema Contains rules and custom error messages\n   * @param {Object} options Contains name of element being validated and previous errors\n   * @param {Function} callback Called and passed the errors after validation\n   */\n  validate: function validate(data, schema, options, callback) {\n    // If the whole form has been submitted, then activate all rules\n    var forceActive = !options.key;\n    var validator = this.createValidator(data, schema, forceActive);\n\n    var getErrors = function getErrors() {\n      // If a single element is being validated, just get those errors.\n      // Otherwise get all of them.\n      if (options.key) {\n        options.prevErrors[options.key] = validator.errors.get(options.key);\n        callback(options.prevErrors);\n      } else {\n        callback(validator.errors.all());\n      }\n    }; // Run the validator asynchronously in case any async rules have been a`dded\n\n\n    validator.checkAsync(getErrors, getErrors);\n  },\n\n  /**\n   * Validate server-side returning a Promise to easier handle results.\n   * All inactive rules will be forced to activate.\n   *\n   * @param {Object} data The data submitted\n   * @param {Object} schema Contains rules and custom error messages\n   * @returns {Promise}\n   */\n  validateServer: function validateServer(data, schema) {\n    var validator = this.createValidator(data, schema, true);\n    var Error = this.Error;\n    return new Promise(function (resolve, reject) {\n      validator.checkAsync(resolve, function () {\n        var e = new Error('A validation error occurred');\n        e.errors = validator.errors.all();\n        reject(e);\n      });\n    });\n  },\n\n  /**\n   * Error class. Created by validateServer when validation fails.\n   * Exists so that middleware can check it with instanceof: if (err instanceof strategy.Error)\n   *\n   * @property {Object} errors Contains the error messages by field name.\n   */\n  Error: function Error(message) {\n    this.message = message;\n    this.errors = {};\n  }\n};","map":null,"metadata":{},"sourceType":"script"}