{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = validationMixin;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _lodash = require('lodash.result');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _validationFactory = require('../validationFactory');\n\nvar _validationFactory2 = _interopRequireDefault(_validationFactory);\n\nvar _reactDisplayName = require('react-display-name');\n\nvar _reactDisplayName2 = _interopRequireDefault(_reactDisplayName);\n\nvar _utils = require('../utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction validationMixin(strategy) {\n  var validator = (0, _validationFactory2.default)(strategy);\n  return function wrappedComponentFn(WrappedComponent) {\n    (0, _invariant2.default)((0, _utils.defined)(WrappedComponent), 'Component was not provided to the Validator. Export you Component with \"export default validator(strategy)(Component);\"');\n\n    var Validation = function (_React$Component) {\n      _inherits(Validation, _React$Component);\n\n      function Validation(props, context) {\n        _classCallCheck(this, Validation);\n\n        var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n        _this.render = _this.render.bind(_this);\n        _this.validate = _this.validate.bind(_this);\n        _this.isValid = _this.isValid.bind(_this);\n        _this.getValidationMessages = _this.getValidationMessages.bind(_this);\n        _this.clearValidations = _this.clearValidations.bind(_this);\n        _this.handleValidation = _this.handleValidation.bind(_this);\n        _this._invokeCallback = _this._invokeCallback.bind(_this);\n        _this.state = {\n          errors: {}\n        };\n        return _this;\n      }\n      /* Get current validation messages for a specified key or entire form.\n       *\n       * @param {?String} key to get messages, or entire form if key is undefined.\n       * @return {Array}\n       */\n\n\n      Validation.prototype.getValidationMessages = function getValidationMessages(key) {\n        return validator.getValidationMessages(this.state.errors, key) || [];\n      };\n      /* Convenience method to validate a key via an event handler. Useful for\n       * onBlur, onClick, onChange, etc...\n       *\n       * @param {?String} State key to validate\n       * @return {function} validation event handler\n       */\n\n\n      Validation.prototype.handleValidation = function handleValidation(key, callback) {\n        var _this2 = this;\n\n        return function () {\n          _this2.validate(key, callback);\n        };\n      };\n      /* Method to validate single form key or entire form against the component data.\n       *\n       * @param {String|Function} key to validate, or error-first containing the validation errors if any.\n       * @param {?Function} error-first callback containing the validation errors if any.\n       */\n\n\n      Validation.prototype.validate = function validate()\n      /* [key], callback */\n      {\n        var _this3 = this;\n\n        var fallback = arguments.length <= 1 && typeof arguments[0] === 'function' ? arguments[0] : undefined;\n        var key = arguments.length <= 1 && typeof arguments[0] === 'function' ? undefined : arguments[0];\n        var callback = arguments.length <= 2 && typeof arguments[1] === 'function' ? arguments[1] : fallback;\n        var data = (0, _lodash2.default)(this.refs.component, 'getValidatorData');\n        var schema = (0, _lodash2.default)(this.refs.component, 'validatorTypes');\n        (0, _invariant2.default)((0, _utils.defined)(data), 'Data was not provided to the Validator. Implement \"getValidatorData\" to return data.');\n        (0, _invariant2.default)((0, _utils.defined)(schema), 'A schema was not provided to the Validator. Implement \"validatorTypes\" to return a validation schema.');\n        var options = {\n          key: key,\n          prevErrors: this.state.errors\n        };\n        validator.validate(data, schema, options, function (nextErrors) {\n          _this3.setState({\n            errors: _extends({}, nextErrors)\n          }, _this3._invokeCallback.bind(_this3, key, callback));\n        });\n      };\n      /* Clear all previous validations\n       *\n       * @return {void}\n       */\n\n\n      Validation.prototype.clearValidations = function clearValidations(callback) {\n        return this.setState({\n          errors: {}\n        }, callback);\n      };\n      /* Check current validity for a specified key or entire form.\n       *\n       * @param {?String} key to check validity (entire form if undefined).\n       * @return {Boolean}.\n       */\n\n\n      Validation.prototype.isValid = function isValid(key) {\n        return validator.isValid(this.state.errors, key);\n      };\n      /* Private method that handles executing users callback on validation\n       *\n       * @param {Object} errors object keyed on data field names.\n       * @param {Function} error-first callback containing the validation errors if any.\n       */\n\n\n      Validation.prototype._invokeCallback = function _invokeCallback(key, callback) {\n        if (typeof callback !== 'function') {\n          return;\n        }\n\n        if (this.isValid(key)) {\n          callback();\n        } else {\n          callback(this.state.errors);\n        }\n      };\n\n      Validation.prototype.render = function render() {\n        return _react2.default.createElement(WrappedComponent, _extends({\n          ref: 'component',\n          errors: this.state.errors,\n          validate: this.validate,\n          isValid: this.isValid,\n          getValidationMessages: this.getValidationMessages,\n          clearValidations: this.clearValidations,\n          handleValidation: this.handleValidation\n        }, this.props));\n      };\n\n      return Validation;\n    }(_react2.default.Component);\n\n    Validation.displayName = 'Validation(' + (0, _reactDisplayName2.default)(WrappedComponent) + ')';\n    return Validation;\n  };\n}","map":null,"metadata":{},"sourceType":"script"}