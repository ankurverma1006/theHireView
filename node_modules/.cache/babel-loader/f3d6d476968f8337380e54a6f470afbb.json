{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Ankur\\\\Desktop\\\\therapidhire\\\\therapidhireui\\\\TheRapidHireUI\\\\src\\\\videoChat\\\\js\\\\app.js\";\nimport React, { Component } from 'react';\nimport { render } from 'react-dom';\nimport _ from 'lodash';\nimport socket from './socket';\nimport PeerConnection from './PeerConnection';\nimport MainWindow from './MainWindow';\nimport CallWindow from './CallWindow';\nimport CallModal from './CallModal'; //import { captureUserMedia, S3Upload } from './AppUtils';\n\nimport RecordRTC from 'recordrtc';\nimport { Modal } from 'react-bootstrap';\nimport { connect } from 'react-redux'; //import MultiStreamsMixer from 'multistreamsmixer';\n\nimport $ from 'jquery';\nimport Header from '../header/header';\nimport theRapidHireApiService from '../../common/core/api/apiService'; //import {MediaStreamRecorder} from '/MediaStreamRecorder.js';\n//import MediaStreamRecorder from '../../../node_modules/msr/MediaStreamRecorder.js';\n\nconst hasGetUserMedia = !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia); //loadScript('https://sdk.amazonaws.com/js/aws-sdk-2.2.32.min.js')\n\nvar AWS = require('aws-sdk'); //var multiStreamRecorder;\n\n\nconst config = {\n  bucketName: 'ankurself',\n  dirName: 'photos',\n\n  /* optional */\n  region: 'ap-south-1',\n  // Put your aws region here\n  accessKeyId: 'AKIAJHHM3PCJ25PK6OWQ',\n  secretAccessKey: 'fTo0CpSivV7OWo2TrFGNUaA5E6ST1pB9Pwnsp5HB'\n};\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      clientId: '',\n      callWindow: '',\n      callModal: '',\n      callFrom: '',\n      localSrc: null,\n      peerSrc: null,\n      recordVideo: null\n    };\n    var wRegion = \"ap-south-1\";\n    var poolid = 'ap-south-1:5075a328-2598-4e55-ba57-d4b60ed9548c';\n    var s3bucketName = \"ankurself\";\n    var audioPath = \"/audio-files\";\n    var s3bucketName = \"ankurself\";\n    var audioPath = \"/audio-files\";\n    var audioStoreWithBucket = s3bucketName + audioPath; //AudioStream = new AudioStream(wRegion,poolid,s3bucketName+audioPath)\n\n    this.region = \"ap-south-1\"; //s3 region\n\n    this.IdentityPoolId = 'ap-south-1:5075a328-2598-4e55-ba57-d4b60ed9548c'; //identity pool id\n\n    this.bucketName = audioStoreWithBucket; //audio file store\n\n    this.s3 = ''; //variable defination for s3\n\n    this.dateinfo = new Date();\n    this.timestampData = this.dateinfo.getTime(); //timestamp used for file uniqueness\n\n    this.etag = []; // etag is used to save the parts of the single upload file\n\n    this.recordedChunks = []; //empty Array\n\n    this.booleanStop = false; // this is for final multipart complete\n\n    this.incr = 0; // multipart requires incremetal so that they can merge all parts by ascending order\n\n    this.filename = this.timestampData.toString() + \".webm\"; //unique filename\n\n    this.uploadId = \"\"; // upload id is required in multipart\n\n    this.recorder = ''; //initializing recorder variable\n\n    this.multiStreamRecorder = '';\n    this.player = '';\n    this.localSource = ''; //To use microphone it shud be {audio: true}\n\n    this.audioConstraints = {\n      audio: true,\n      video: true,\n      audio: {\n        echoCancellation: true\n      }\n    };\n    this.pc = {};\n    this.config = null;\n    this.startCallHandler = this.startCall.bind(this);\n    this.startCallByInterviewer = this.startCallInterviewer.bind(this);\n    this.endCallHandler = this.endCall.bind(this);\n    this.rejectCallHandler = this.rejectCall.bind(this);\n    this.requestUserMedia = this.requestUserMedia.bind(this);\n  }\n\n  componentDidMount() {\n    var script = document.createElement(\"script\");\n    script.src = \"../dist/js/app.min.js\";\n    script.async = true;\n    document.body.appendChild(script);\n\n    if (!hasGetUserMedia) {\n      alert(\"Your browser cannot stream from your webcam. Please switch to Chrome or Firefox.\");\n      return;\n    }\n\n    console.log(this.props.location.state);\n    this.setState({\n      slotId: this.props.location.state.slotId\n    });\n    socket.on('init', data => this.setState({\n      clientId: this.props.location.state.videoKeySelf\n    })) // to another user's id\n    .on('request', data => {\n      console.log(data);\n      this.setState({\n        callModal: 'active',\n        callFrom: data.from\n      });\n    }).on('call', data => {\n      if (data.sdp) {\n        this.pc.setRemoteDescription(data.sdp);\n        if (data.sdp.type === 'offer') this.pc.createAnswer();\n      } else this.pc.addIceCandidate(data.candidate);\n    }).on('end', this.endCall.bind(this, false)).emit('init', this.props.location.state.videoKeySelf); // self id kept\n  }\n\n  componentWillMount() {\n    // this.requestUserMedia();\n    this.audioStreamInitialize();\n  }\n\n  requestUserMedia() {\n    console.log('requestUserMedia'); //   captureUserMedia((stream) => {\n    //     this.setState({ localSrc: stream});\n    //     this.setState({ peerSrc : stream});\n    //     console.log('setting state', this.state)\n    //   });\n  }\n\n  audioStreamInitialize() {\n    /*\r\n        Creates a new credentials object, which will allow us to communicate with the aws services.\r\n    */\n    var self = this;\n    AWS.config.update({\n      region: \"ap-south-1\",\n      credentials: new AWS.CognitoIdentityCredentials({\n        IdentityPoolId: 'ap-south-1:5075a328-2598-4e55-ba57-d4b60ed9548c',\n        RoleArn: 'arn:aws:iam::923146643705:role/Cognito_TestPoolUnauth_Role',\n        AccountId: '923146643705' // your AWS account ID\n\n      })\n    });\n    AWS.config.credentials.get(function (err) {\n      if (err) console.log(err);else console.log(AWS.config.credentials);\n    });\n    self.s3 = new AWS.S3({\n      logger: console,\n      //         AWSAccessKeyId=AKIAJRQYW4X2EL2WE6UQ\n      // AWSSecretKey=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\n      apiVersion: '2006-03-01',\n      params: {\n        Bucket: 'ankurself'\n      }\n    });\n    /*\r\n        Feature detecting is a simple check for the existence of \"navigator.mediaDevices.getUserMedia\"\r\n        To use the microphone. we need to request permission.\r\n        The parameter to getUserMedia() is an object specifying the details and requirements for each type of media you want to access.\r\n        To use microphone it shud be {audio: true}\r\n    */\n    //   navigator.mediaDevices.getUserMedia(self.audioConstraints)\n    //       .then(function(stream) {\n    //           /*\n    //               once we accept the prompt for the audio stream from user's mic we enable the record button.\n    //           */\n    //         //  $(\"#record_q1\").removeAttr(\"disabled\");\n    //           /*\n    //               Creates a new MediaRecorder object, given a MediaStream to record.\n    //           */\n    //           self.recorder = new MediaRecorder(stream);\n    //                           self.setState({videosrc:stream});                               \n    //           self.recorder.addEventListener('dataavailable', function(e) {\n    //               var normalArr = [];\n    //               /*\n    //                   Here we push the stream data to an array for future use.\n    //               */\n    //               self.recordedChunks.push(e.data);\n    //               normalArr.push(e.data);\n    //               /*\n    //                   here we create a blob from the stream data that we have received.\n    //               */\n    //               var blob = new Blob(normalArr, {\n    //                   type: 'video/webm'\n    //               });\n    //               /*\n    //                   if the length of recordedChunks is 1 then it means its the 1st part of our data.\n    //                   So we createMultipartUpload which will return an upload id.\n    //                   Upload id is used to upload the other parts of the stream\n    //                   else.\n    //                   It Uploads a part in a multipart upload.\n    //               */\n    //               if (self.recordedChunks.length == 1) {\n    //                        console.log(blob.size);\n    //                   self.startMultiUpload(blob, self.filename)\n    //               } else {\n    //                   /*\n    //                       self.incr is basically a part number.\n    //                       Part number of part being uploaded. This is a positive integer between 1 and 10,000.\n    //                   */\n    //                   self.incr = self.incr + 1\n    //                   self.continueMultiUpload(blob, self.incr, self.uploadId, self.filename, self.bucketName);\n    //               }\n    //           })\n    //       });\n    //  this.startRecording(isCaller);\n    //    navigator.mediaDevices.getUserMedia({\n    //     video: true,\n    //     audio: true\n    // }).then(async function(stream) {\n    //     self.state.recordVideo = RecordRTC(stream, {     \n    //     // disable logs\n    //     disableLogs: true,\n    //     // disable logs\n    //     disableLogs: true,\n    //     // get intervals based blobs\n    //     // value in milliseconds\n    //     timeSlice: 150000,\n    //     ondataavailable: function(e) {\n    //     console.log('ondataavailable -- ');\n    //       var normalArr = [];\n    //       /*\n    //           Here we push the stream data to an array for future use.\n    //       */\n    //       self.recordedChunks.push(e.data);\n    //       normalArr.push(e.data);\n    //       /*\n    //           here we create a blob from the stream data that we have received.\n    //       */\n    //       var blob = new Blob(normalArr, {\n    //           type: 'video/webm'\n    //       });                   \n    //   //    let size = bytesToSize(recorder.getBlob().size);\n    //       if (self.recordedChunks.length == 1) {\n    //                console.log(blob.size);\n    //           self.startMultiUpload(blob, self.filename)\n    //       } else {\n    //           /*\n    //               self.incr is basically a part number.\n    //               Part number of part being uploaded. This is a positive integer between 1 and 10,000.\n    //           */\n    //           self.incr = self.incr + 1\n    //           self.continueMultiUpload(blob, self.incr, self.uploadId, self.filename, self.bucketName);\n    //       }}\n    //   });      \n    //});\n  }\n\n  startRecording(id) {\n    var self = this;\n    this.recorder.start(50000);\n    console.log('recprdomg');\n    this.setState({\n      showVideo: true\n    });\n  }\n\n  stopRecording(id) {\n    var self = this;\n    self.recorder.stop();\n    self.booleanStop = true; //disable self\n    //  self.disableAllButton()\n    //  $(\"#stop_q1\").attr(\"disabled\", \"disabled\");\n    // add loader\n    //  self.setLoader();\n\n    this.setState({\n      showVideo: false\n    });\n  }\n\n  pauseRecording(id) {\n    var self = this;\n    self.recorder.pause();\n    $(\"#pause_q1\").addClass(\"hide\");\n    $(\"#resume_q1\").removeClass(\"hide\");\n  }\n\n  resumeRecording(id) {\n    var self = this;\n    self.recorder.resume();\n    $(\"#resume_q1\").addClass(\"hide\");\n    $(\"#pause_q1\").removeClass(\"hide\");\n  }\n\n  startMultiUpload(blob, filename) {\n    var self = this;\n    var audioBlob = blob;\n    var params = {\n      Bucket: 'ankurself',\n      Key: filename,\n      ContentType: 'video/webm',\n      ACL: 'public-read'\n    };\n    self.s3.createMultipartUpload(params, function (err, data) {\n      if (err) {\n        console.log(err, err.stack); // an error occurred\n      } else {\n        self.uploadId = data.UploadId;\n        self.incr = 1;\n        self.continueMultiUpload(audioBlob, self.incr, self.uploadId, self.filename, self.bucketName);\n      }\n    });\n  }\n  /*\r\n        Uploads a part in a multipart upload.\r\n        The following code uploads part of a multipart upload.\r\n        it specifies a file name for the part data. The Upload ID is same that is returned by the initiate multipart upload.\r\n    */\n\n\n  continueMultiUpload(audioBlob, PartNumber, uploadId, key, bucketName) {\n    var self = this;\n    var params = {\n      Body: audioBlob,\n      Bucket: 'ankurself',\n      Key: key,\n      PartNumber: PartNumber,\n      UploadId: uploadId\n    };\n    console.log(params);\n    self.s3.uploadPart(params, function (err, data) {\n      if (err) {\n        console.log(err, err.stack);\n      } // an error occurred\n      else {\n          /*\r\n              Once the part of data is uploaded we get an Entity tag for the uploaded object(ETag).\r\n              which is used later when we complete our multipart upload.\r\n          */\n          self.etag.push(data.ETag);\n\n          if (self.booleanStop == true) {\n            self.completeMultiUpload();\n          }\n        }\n    });\n  }\n  /*\r\n        Completes a multipart upload by assembling previously uploaded parts.\r\n    */\n\n\n  completeMultiUpload() {\n    var self = this;\n    var outputTag = [];\n    /*\r\n        here we are constructing the Etag data in the required format.\r\n    */\n\n    self.etag.forEach((data, index) => {\n      const obj = {\n        ETag: data,\n        PartNumber: ++index\n      };\n      outputTag.push(obj);\n    });\n    var params = {\n      Bucket: 'ankurself',\n      // required\n      Key: self.filename,\n      // required\n      UploadId: self.uploadId,\n      // required\n      MultipartUpload: {\n        Parts: outputTag\n      }\n    };\n    self.s3.completeMultipartUpload(params, function (err, data) {\n      if (err) {\n        console.log(err, err.stack);\n      } // an error occurred\n      else {\n          self.saveVideoURL(data.Location); // initialize variable back to normal\n\n          self.etag = [];\n          self.recordedChunks = [];\n          self.uploadId = \"\";\n          self.booleanStop = false; //  self.disableAllButton();\n          //   self.removeLoader();\n\n          alert(\"we have successfully saved the questionaire..\");\n        }\n    });\n  }\n\n  saveVideoURL(videoLink) {\n    let data = {\n      slotId: this.state.slotId,\n      userId: this.props.user.userId,\n      videoChatLink: videoLink\n    }; //facebook app secret --   appID --1928279157274431\n    //8cfe05bdd0ecbdfa3d51460f2d9b21ae\n\n    theRapidHireApiService('saveChatLink', data).then(response => {\n      if (response.data.status === 'Success') {}\n    }).catch(err => {\n      console.log(err);\n    });\n  }\n\n  startCallInterviewer() {\n    console.log('startCallInterviewer');\n    this.multiStreamRecorder.startRecording();\n  }\n\n  startCall(isCaller, friendID, config) {\n    this.config = config;\n    let self = this; // try array format to record parallely ---    \n\n    let local, remote; //    if(this.props.user.roleId == 2){\n    //     this.pc = new PeerConnection(this.props.location.state.videoKeyClient)\n    //       .on('localStream', (src) => {\n    //         const newState = { callWindow: 'active', localSrc: src };        \n    //         if (!isCaller) newState.callModal = '';\n    //         this.multiStreamRecorder = new RecordRTC([src]);\n    //         this.multiStreamRecorder.stream = src;\n    //     //    multiStreamRecorder.mimeType = 'audio/webm';\n    //     this.multiStreamRecorder.mimeType = 'video/webm';\n    //     this.multiStreamRecorder.previewStream = function(stream) {\n    //       //    video.srcObject = stream;\n    //         //  video.play();\n    //       };\n    //       this.multiStreamRecorder.ondataavailable = function(e) {\n    //          //   appendLink(blob);\n    //          var normalArr = [];\n    //          /*\n    //              Here we push the stream data to an array for future use.\n    //          */\n    //          self.recordedChunks.push(e);\n    //          normalArr.push(e);\n    //                 // //   appendLink(blob);\n    //                 // let MB = 5 * 1024 * 1024\n    //                 // let size = self.bytesToSize(e.size);\n    //                 // console.log(e.size >= MB);\n    //                 // /*\n    //                 //     Here we push the stream data to an array for future use.\n    //                 // */\n    //                 // vardata.push(e);\n    //                 // // normalArr.push(e);\n    //                 // let checkSize=0;\n    //                 // vardata.forEach(function(data){\n    //                 //     checkSize = checkSize + data.size;\n    //                 // })\n    //                 // console.log('checkSize -- ',checkSize);\n    //                 // if(checkSize <= MB )\n    //                 // return false;\n    //                 // self.recordedChunks.push = [];\n    //          /*\n    //              here we create a blob from the stream data that we have received.\n    //          */\n    //          var blob = new Blob(normalArr, {\n    //              type: 'video/webm'\n    //          });                   \n    //          let size = self.bytesToSize(e.size);\n    //          console.log('size ',size);\n    //         console.log('recordedChunks -- ',self.recordedChunks);\n    //          if (self.recordedChunks.length == 1) {\n    //                   console.log(blob.size);\n    //                   console.log('startMultiUpload -- ',);\n    //              self.startMultiUpload(e, self.filename)\n    //          } else {\n    //              /*\n    //                  self.incr is basically a part number.\n    //                  Part number of part being uploaded. This is a positive integer between 1 and 10,000.\n    //              */\n    //             console.log('continueMultiUpload -- ',);\n    //              self.incr = self.incr + 1\n    //              self.continueMultiUpload(e, self.incr, self.uploadId, self.filename, self.bucketName);\n    //          }\n    //         }; \n    //         local= src;\n    //         this.setState(newState);\n    //       })\n    //       .on('peerStream', src =>{\n    //         this.multiStreamRecorder.addStream( src );\n    //         this.setState({ peerSrc: src });\n    //       })\n    //       .start(isCaller, config);\n    //     }else{\n    //         this.pc = new PeerConnection(this.props.location.state.videoKeyClient)\n    //         .on('localStream', (src) => {\n    //           const newState = { callWindow: 'active', localSrc: src };        \n    //           if (!isCaller) newState.callModal = '';        \n    //           this.setState(newState);        \n    //         })\n    //         .on('peerStream', src =>{       \n    //           this.setState({ peerSrc: src });        \n    //         })\n    //         .start(isCaller, config);\n    //     }\n\n    if (this.props.user.roleId == 2) {\n      this.pc = new PeerConnection(this.props.location.state.videoKeyClient).on('localStream', src => {\n        const newState = {\n          callWindow: 'active',\n          localSrc: src\n        };\n        console.log(src);\n        this.localSource = src;\n        if (!isCaller) newState.callModal = '';\n        this.setState(newState);\n      }).on('peerStream', src => {\n        this.multiStreamRecorder = RecordRTC([this.localSource, src], {\n          // audio, video, canvas, gif\n          type: 'video',\n          mimeType: 'video/mp4',\n          recorderType: RecordRTC.MultiStreamRecorder,\n          // disable logs\n          disableLogs: true,\n          // get intervals based blobs\n          // value in milliseconds\n          timeSlice: 180000,\n          // requires timeSlice above\n          // returns blob via callback function\n          ondataavailable: function (e) {\n            var normalArr = [];\n            /*\r\n                Here we push the stream data to an array for future use.\r\n            */\n\n            self.recordedChunks.push(e);\n            normalArr.push(e); // //   appendLink(blob);\n            // let MB = 5 * 1024 * 1024\n            // let size = self.bytesToSize(e.size);\n            // console.log(e.size >= MB);\n            // /*\n            //     Here we push the stream data to an array for future use.\n            // */\n            // vardata.push(e);\n            // // normalArr.push(e);\n            // let checkSize=0;\n            // vardata.forEach(function(data){\n            //     checkSize = checkSize + data.size;\n            // })\n            // console.log('checkSize -- ',checkSize);\n            // if(checkSize <= MB )\n            // return false;\n            // self.recordedChunks.push = [];\n\n            /*\r\n                here we create a blob from the stream data that we have received.\r\n            */\n            //  var blob = new Blob(normalArr, {\n            //      type: 'video/webm'\n            //  });                   \n\n            let size = self.bytesToSize(e.size);\n            console.log('size ', size);\n            console.log('recordedChunks -- ', self.recordedChunks);\n\n            if (self.recordedChunks.length == 1) {\n              //     console.log(blob.size);\n              console.log('startMultiUpload -- ');\n              self.startMultiUpload(e, self.filename);\n            } else {\n              /*\r\n                  self.incr is basically a part number.\r\n                  Part number of part being uploaded. This is a positive integer between 1 and 10,000.\r\n              */\n              console.log('continueMultiUpload -- ');\n              self.incr = self.incr + 1;\n              self.continueMultiUpload(e, self.incr, self.uploadId, self.filename, self.bucketName);\n            }\n          },\n          // auto stop recording if camera stops\n          checkForInactiveTracks: false,\n          // requires timeSlice above\n          onTimeStamp: function (timestamp) {},\n          // both for audio and video tracks\n          bitsPerSecond: 128000,\n          // if you are recording multiple streams into single file\n          // this helps you see what is being recorded\n          previewStream: function (stream) {\n            console.log(stream);\n          },\n          // used by MultiStreamRecorder - to access HTMLCanvasElement\n          elementClass: 'multi-streams-mixer'\n        });\n        this.setState({\n          peerSrc: src\n        });\n      }).start(isCaller, config);\n    } else {\n      this.pc = new PeerConnection(this.props.location.state.videoKeyClient).on('localStream', src => {\n        const newState = {\n          callWindow: 'active',\n          localSrc: src\n        };\n        if (!isCaller) newState.callModal = '';\n        this.setState(newState);\n      }).on('peerStream', src => {\n        this.setState({\n          peerSrc: src\n        });\n      }).start(isCaller, config);\n    }\n  }\n\n  bytesToSize(bytes) {\n    var k = 1000;\n    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    if (bytes === 0) return '0 Bytes';\n    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(k)), 10);\n    return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];\n  }\n\n  rejectCall() {\n    const callFrom = this.state.callFrom;\n    socket.emit('end', {\n      to: callFrom\n    });\n    this.setState({\n      callModal: ''\n    });\n  }\n\n  endCall(isStarter) {\n    if (this.props.user.roleId == 2) this.multiStreamRecorder.stopRecording();\n    if (_.isFunction(this.pc.stop)) this.pc.stop(isStarter);\n    this.pc = {};\n    this.config = null;\n    this.setState({\n      callWindow: '',\n      localSrc: null,\n      peerSrc: null\n    }); // this.stopRecording(1);\n    //  this.state.recordVideo.stopRecording();\n\n    this.booleanStop = true; //     this.state.recordVideo.stopRecording(() => {\n    //       let params = {\n    //         type: 'video/webm',\n    //         data: this.state.recordVideo.blob,\n    //         id: Math.floor(Math.random()*90000) + 10000\n    //       }\n    //  console.log('enter then statement')\n    //   //    this.setState({ uploading: true });\n    //       S3Upload(params)\n    //       .then((success) => {\n    //         console.log('enter then statement')\n    //         if(success) {\n    //           console.log(success)\n    //      //     this.setState({ uploadSuccess: true, uploading: false });\n    //         }\n    //       }, (error) => {\n    //         alert(error, 'error occurred. check your aws settings and try again.')\n    //       })\n    //     });\n  }\n\n  render() {\n    const _this$state = this.state,\n          clientId = _this$state.clientId,\n          callFrom = _this$state.callFrom,\n          callModal = _this$state.callModal,\n          callWindow = _this$state.callWindow,\n          localSrc = _this$state.localSrc,\n          peerSrc = _this$state.peerSrc;\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 729\n      },\n      __self: this\n    }, React.createElement(Header, Object.assign({}, this.props, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 730\n      },\n      __self: this\n    })), React.createElement(MainWindow, {\n      clientId: clientId,\n      startCall: this.startCallHandler,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 731\n      },\n      __self: this\n    }), React.createElement(CallWindow, {\n      status: callWindow,\n      localSrc: localSrc,\n      peerSrc: peerSrc,\n      config: this.config,\n      mediaDevice: this.pc.mediaDevice,\n      endCall: this.endCallHandler,\n      user: this.props.user,\n      startCallInterviewer: this.startCallByInterviewer,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 736\n      },\n      __self: this\n    }), React.createElement(CallModal, {\n      status: callModal,\n      startCall: this.startCallHandler,\n      rejectCall: this.rejectCallHandler,\n      callFrom: callFrom,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 746\n      },\n      __self: this\n    }));\n  }\n\n}\n\nconst mapStateToProps = state => {\n  return {\n    user: state.User.userData\n  };\n};\n\nexport default connect(mapStateToProps, null)(App);","map":{"version":3,"sources":["C:\\Users\\Ankur\\Desktop\\therapidhire\\therapidhireui\\TheRapidHireUI\\src\\videoChat\\js\\app.js"],"names":["React","Component","render","_","socket","PeerConnection","MainWindow","CallWindow","CallModal","RecordRTC","Modal","connect","$","Header","theRapidHireApiService","hasGetUserMedia","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","AWS","require","config","bucketName","dirName","region","accessKeyId","secretAccessKey","App","constructor","props","state","clientId","callWindow","callModal","callFrom","localSrc","peerSrc","recordVideo","wRegion","poolid","s3bucketName","audioPath","audioStoreWithBucket","IdentityPoolId","s3","dateinfo","Date","timestampData","getTime","etag","recordedChunks","booleanStop","incr","filename","toString","uploadId","recorder","multiStreamRecorder","player","localSource","audioConstraints","audio","video","echoCancellation","pc","startCallHandler","startCall","bind","startCallByInterviewer","startCallInterviewer","endCallHandler","endCall","rejectCallHandler","rejectCall","requestUserMedia","componentDidMount","script","document","createElement","src","async","body","appendChild","alert","console","log","location","setState","slotId","on","data","videoKeySelf","from","sdp","setRemoteDescription","type","createAnswer","addIceCandidate","candidate","emit","componentWillMount","audioStreamInitialize","self","update","credentials","CognitoIdentityCredentials","RoleArn","AccountId","get","err","S3","logger","apiVersion","params","Bucket","startRecording","id","start","showVideo","stopRecording","stop","pauseRecording","pause","addClass","removeClass","resumeRecording","resume","startMultiUpload","blob","audioBlob","Key","ContentType","ACL","createMultipartUpload","stack","UploadId","continueMultiUpload","PartNumber","key","Body","uploadPart","push","ETag","completeMultiUpload","outputTag","forEach","index","obj","MultipartUpload","Parts","completeMultipartUpload","saveVideoURL","Location","videoLink","userId","user","videoChatLink","then","response","status","catch","isCaller","friendID","local","remote","roleId","videoKeyClient","newState","mimeType","recorderType","MultiStreamRecorder","disableLogs","timeSlice","ondataavailable","e","normalArr","size","bytesToSize","length","checkForInactiveTracks","onTimeStamp","timestamp","bitsPerSecond","previewStream","stream","elementClass","bytes","k","sizes","i","parseInt","Math","floor","pow","toPrecision","to","isStarter","isFunction","mediaDevice","mapStateToProps","User","userData"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAASC,MAAT,QAAuB,WAAvB;AACA,OAAOC,CAAP,MAAc,QAAd;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,SAAP,MAAsB,aAAtB,C,CACA;;AACA,OAAOC,SAAP,MAAsB,WAAtB;AACA,SAASC,KAAT,QAAsB,iBAAtB;AACA,SAASC,OAAT,QAAwB,aAAxB,C,CACA;;AACA,OAAOC,CAAP,MAAc,QAAd;AACA,OAAOC,MAAP,MAAmB,kBAAnB;AACA,OAAOC,sBAAP,MAAmC,kCAAnC,C,CACA;AACA;;AACA,MAAMC,eAAe,GAAG,CAAC,EAAEC,SAAS,CAACC,YAAV,IAA0BD,SAAS,CAACE,kBAApC,IACHF,SAAS,CAACG,eADP,IAC0BH,SAAS,CAACI,cADtC,CAAzB,C,CAGwB;;AAExB,IAAIC,GAAG,GAAGC,OAAO,CAAC,SAAD,CAAjB,C,CACA;;;AACA,MAAMC,MAAM,GAAG;AACbC,EAAAA,UAAU,EAAE,WADC;AAEbC,EAAAA,OAAO,EAAE,QAFI;;AAEM;AACnBC,EAAAA,MAAM,EAAE,YAHK;AAGS;AACtBC,EAAAA,WAAW,EAAE,sBAJA;AAKbC,EAAAA,eAAe,EAAE;AALJ,CAAf;;AAQA,MAAMC,GAAN,SAAkB5B,SAAlB,CAA4B;AAC1B6B,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,UAAMA,KAAN;AACA,SAAKC,KAAL,GAAa;AACXC,MAAAA,QAAQ,EAAE,EADC;AAEXC,MAAAA,UAAU,EAAE,EAFD;AAGXC,MAAAA,SAAS,EAAE,EAHA;AAIXC,MAAAA,QAAQ,EAAE,EAJC;AAKXC,MAAAA,QAAQ,EAAE,IALC;AAMXC,MAAAA,OAAO,EAAE,IANE;AAOXC,MAAAA,WAAW,EAAE;AAPF,KAAb;AASA,QAAIC,OAAO,GAAG,YAAd;AACA,QAAIC,MAAM,GAAG,iDAAb;AACA,QAAIC,YAAY,GAAG,WAAnB;AACA,QAAIC,SAAS,GAAG,cAAhB;AACA,QAAID,YAAY,GAAG,WAAnB;AACA,QAAIC,SAAS,GAAG,cAAhB;AACA,QAAIC,oBAAoB,GAACF,YAAY,GAACC,SAAtC,CAjBiB,CAkBjB;;AAEA,SAAKjB,MAAL,GAAc,YAAd,CApBiB,CAoBW;;AAC5B,SAAKmB,cAAL,GAAsB,iDAAtB,CArBiB,CAqBwD;;AACzE,SAAKrB,UAAL,GAAkBoB,oBAAlB,CAtBiB,CAsBuB;;AACxC,SAAKE,EAAL,GAAQ,EAAR,CAvBiB,CAuBL;;AACZ,SAAKC,QAAL,GAAgB,IAAIC,IAAJ,EAAhB;AACA,SAAKC,aAAL,GAAqB,KAAKF,QAAL,CAAcG,OAAd,EAArB,CAzBiB,CAyB6B;;AAC9C,SAAKC,IAAL,GAAY,EAAZ,CA1BiB,CA0BD;;AAChB,SAAKC,cAAL,GAAsB,EAAtB,CA3BiB,CA2BS;;AAC1B,SAAKC,WAAL,GAAmB,KAAnB,CA5BiB,CA4BS;;AAC1B,SAAKC,IAAL,GAAY,CAAZ,CA7BiB,CA6BF;;AACf,SAAKC,QAAL,GAAgB,KAAKN,aAAL,CAAmBO,QAAnB,KAAgC,OAAhD,CA9BiB,CA8BwC;;AACzD,SAAKC,QAAL,GAAgB,EAAhB,CA/BiB,CA+BG;;AACpB,SAAKC,QAAL,GAAc,EAAd,CAhCiB,CAgCC;;AAClB,SAAKC,mBAAL,GAAyB,EAAzB;AACA,SAAKC,MAAL,GAAY,EAAZ;AACA,SAAKC,WAAL,GAAiB,EAAjB,CAnCiB,CAoCjB;;AACA,SAAKC,gBAAL,GAAwB;AACpBC,MAAAA,KAAK,EAAE,IADa;AAEpBC,MAAAA,KAAK,EAAE,IAFa;AAGpBD,MAAAA,KAAK,EAAE;AAACE,QAAAA,gBAAgB,EAAC;AAAlB;AAHa,KAAxB;AAKA,SAAKC,EAAL,GAAU,EAAV;AACA,SAAK3C,MAAL,GAAc,IAAd;AACA,SAAK4C,gBAAL,GAAwB,KAAKC,SAAL,CAAeC,IAAf,CAAoB,IAApB,CAAxB;AACA,SAAKC,sBAAL,GAA8B,KAAKC,oBAAL,CAA0BF,IAA1B,CAA+B,IAA/B,CAA9B;AAEA,SAAKG,cAAL,GAAsB,KAAKC,OAAL,CAAaJ,IAAb,CAAkB,IAAlB,CAAtB;AACA,SAAKK,iBAAL,GAAyB,KAAKC,UAAL,CAAgBN,IAAhB,CAAqB,IAArB,CAAzB;AACA,SAAKO,gBAAL,GAAwB,KAAKA,gBAAL,CAAsBP,IAAtB,CAA2B,IAA3B,CAAxB;AACD;;AAEDQ,EAAAA,iBAAiB,GAAG;AAClB,QAAIC,MAAM,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAb;AAEAF,IAAAA,MAAM,CAACG,GAAP,GAAa,uBAAb;AACAH,IAAAA,MAAM,CAACI,KAAP,GAAe,IAAf;AAEAH,IAAAA,QAAQ,CAACI,IAAT,CAAcC,WAAd,CAA0BN,MAA1B;;AAGA,QAAG,CAAC/D,eAAJ,EAAqB;AACnBsE,MAAAA,KAAK,CAAC,kFAAD,CAAL;AACA;AACD;;AAEDC,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKxD,KAAL,CAAWyD,QAAX,CAAoBxD,KAAhC;AAEA,SAAKyD,QAAL,CAAc;AAACC,MAAAA,MAAM,EAAE,KAAK3D,KAAL,CAAWyD,QAAX,CAAoBxD,KAApB,CAA0B0D;AAAnC,KAAd;AAGAtF,IAAAA,MAAM,CACHuF,EADH,CACM,MADN,EACcC,IAAI,IAAI,KAAKH,QAAL,CAAc;AAAExD,MAAAA,QAAQ,EAAE,KAAKF,KAAL,CAAWyD,QAAX,CAAoBxD,KAApB,CAA0B6D;AAAtC,KAAd,CADtB,EAC2F;AAD3F,KAEGF,EAFH,CAEM,SAFN,EAEiBC,IAAI,IAAI;AACrBN,MAAAA,OAAO,CAACC,GAAR,CAAYK,IAAZ;AACD,WAAKH,QAAL,CAAc;AAAEtD,QAAAA,SAAS,EAAE,QAAb;AAAuBC,QAAAA,QAAQ,EAAEwD,IAAI,CAACE;AAAtC,OAAd;AACA,KALH,EAMGH,EANH,CAMM,MANN,EAMeC,IAAD,IAAU;AACpB,UAAIA,IAAI,CAACG,GAAT,EAAc;AACZ,aAAK7B,EAAL,CAAQ8B,oBAAR,CAA6BJ,IAAI,CAACG,GAAlC;AACA,YAAIH,IAAI,CAACG,GAAL,CAASE,IAAT,KAAkB,OAAtB,EAA+B,KAAK/B,EAAL,CAAQgC,YAAR;AAChC,OAHD,MAGO,KAAKhC,EAAL,CAAQiC,eAAR,CAAwBP,IAAI,CAACQ,SAA7B;AACR,KAXH,EAYGT,EAZH,CAYM,KAZN,EAYa,KAAKlB,OAAL,CAAaJ,IAAb,CAAkB,IAAlB,EAAwB,KAAxB,CAZb,EAaGgC,IAbH,CAaQ,MAbR,EAae,KAAKtE,KAAL,CAAWyD,QAAX,CAAoBxD,KAApB,CAA0B6D,YAbzC,EAnBkB,CAgCyC;AAC1D;;AAEDS,EAAAA,kBAAkB,GAAE;AACnB;AACC,SAAKC,qBAAL;AACD;;AAED3B,EAAAA,gBAAgB,GAAG;AACjBU,IAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ,EADiB,CAEnB;AACA;AACA;AACA;AACA;AACC;;AAEDgB,EAAAA,qBAAqB,GAAG;AACtB;;;AAGA,QAAIC,IAAI,GAAG,IAAX;AACAnF,IAAAA,GAAG,CAACE,MAAJ,CAAWkF,MAAX,CAAkB;AACb/E,MAAAA,MAAM,EAAE,YADK;AAETgF,MAAAA,WAAW,EAAE,IAAIrF,GAAG,CAACsF,0BAAR,CAAmC;AAC7C9D,QAAAA,cAAc,EAAE,iDAD6B;AAE7C+D,QAAAA,OAAO,EAAE,4DAFoC;AAG7CC,QAAAA,SAAS,EAAE,cAHkC,CAGnB;;AAHmB,OAAnC;AAFJ,KAAlB;AAUQxF,IAAAA,GAAG,CAACE,MAAJ,CAAWmF,WAAX,CAAuBI,GAAvB,CAA2B,UAAUC,GAAV,EAAe;AAClD,UAAIA,GAAJ,EAASzB,OAAO,CAACC,GAAR,CAAYwB,GAAZ,EAAT,KACKzB,OAAO,CAACC,GAAR,CAAYlE,GAAG,CAACE,MAAJ,CAAWmF,WAAvB;AACR,KAHW;AAKRF,IAAAA,IAAI,CAAC1D,EAAL,GAAU,IAAIzB,GAAG,CAAC2F,EAAR,CAAW;AAACC,MAAAA,MAAM,EAAC3B,OAAR;AACzB;AACA;AACK4B,MAAAA,UAAU,EAAE,YAHQ;AAIjBC,MAAAA,MAAM,EAAE;AAACC,QAAAA,MAAM,EAAE;AAAT;AAJS,KAAX,CAAV;AAQA;;;;;;AAMF;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEC;AACL;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACG;;AAEDC,EAAAA,cAAc,CAACC,EAAD,EAAK;AACjB,QAAId,IAAI,GAAG,IAAX;AAEA,SAAK9C,QAAL,CAAc6D,KAAd,CAAoB,KAApB;AACAjC,IAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;AACA,SAAKE,QAAL,CAAc;AAAC+B,MAAAA,SAAS,EAAC;AAAX,KAAd;AACH;;AAEDC,EAAAA,aAAa,CAACH,EAAD,EAAK;AACd,QAAId,IAAI,GAAG,IAAX;AACAA,IAAAA,IAAI,CAAC9C,QAAL,CAAcgE,IAAd;AACAlB,IAAAA,IAAI,CAACnD,WAAL,GAAmB,IAAnB,CAHc,CAId;AAEF;AACA;AACE;AACF;;AACE,SAAKoC,QAAL,CAAc;AAAC+B,MAAAA,SAAS,EAAC;AAAX,KAAd;AACH;;AAEDG,EAAAA,cAAc,CAACL,EAAD,EAAK;AACf,QAAId,IAAI,GAAG,IAAX;AACAA,IAAAA,IAAI,CAAC9C,QAAL,CAAckE,KAAd;AACDhH,IAAAA,CAAC,CAAC,WAAD,CAAD,CAAeiH,QAAf,CAAwB,MAAxB;AACCjH,IAAAA,CAAC,CAAC,YAAD,CAAD,CAAgBkH,WAAhB,CAA4B,MAA5B;AACH;;AAGDC,EAAAA,eAAe,CAACT,EAAD,EAAK;AAChB,QAAId,IAAI,GAAG,IAAX;AACAA,IAAAA,IAAI,CAAC9C,QAAL,CAAcsE,MAAd;AACDpH,IAAAA,CAAC,CAAC,YAAD,CAAD,CAAgBiH,QAAhB,CAAyB,MAAzB;AACCjH,IAAAA,CAAC,CAAC,WAAD,CAAD,CAAekH,WAAf,CAA2B,MAA3B;AACH;;AAEDG,EAAAA,gBAAgB,CAACC,IAAD,EAAO3E,QAAP,EAAiB;AAC7B,QAAIiD,IAAI,GAAG,IAAX;AACA,QAAI2B,SAAS,GAAGD,IAAhB;AACA,QAAIf,MAAM,GAAG;AAETC,MAAAA,MAAM,EAAE,WAFC;AAGTgB,MAAAA,GAAG,EAAE7E,QAHI;AAIT8E,MAAAA,WAAW,EAAE,YAJJ;AAKTC,MAAAA,GAAG,EAAE;AALI,KAAb;AAOA9B,IAAAA,IAAI,CAAC1D,EAAL,CAAQyF,qBAAR,CAA8BpB,MAA9B,EAAsC,UAASJ,GAAT,EAAcnB,IAAd,EAAoB;AACtD,UAAImB,GAAJ,EAAS;AACLzB,QAAAA,OAAO,CAACC,GAAR,CAAYwB,GAAZ,EAAiBA,GAAG,CAACyB,KAArB,EADK,CACwB;AAChC,OAFD,MAEO;AACHhC,QAAAA,IAAI,CAAC/C,QAAL,GAAgBmC,IAAI,CAAC6C,QAArB;AACAjC,QAAAA,IAAI,CAAClD,IAAL,GAAY,CAAZ;AACAkD,QAAAA,IAAI,CAACkC,mBAAL,CAAyBP,SAAzB,EAAoC3B,IAAI,CAAClD,IAAzC,EAA+CkD,IAAI,CAAC/C,QAApD,EAA8D+C,IAAI,CAACjD,QAAnE,EAA6EiD,IAAI,CAAChF,UAAlF;AACH;AACJ,KARD;AASH;AAGA;;;;;;;AAKCkH,EAAAA,mBAAmB,CAACP,SAAD,EAAYQ,UAAZ,EAAwBlF,QAAxB,EAAkCmF,GAAlC,EAAuCpH,UAAvC,EAAmD;AACpE,QAAIgF,IAAI,GAAG,IAAX;AAIA,QAAIW,MAAM,GAAG;AACT0B,MAAAA,IAAI,EAAEV,SADG;AAETf,MAAAA,MAAM,EAAE,WAFC;AAGTgB,MAAAA,GAAG,EAAEQ,GAHI;AAITD,MAAAA,UAAU,EAAEA,UAJH;AAKTF,MAAAA,QAAQ,EAAEhF;AALD,KAAb;AAOA6B,IAAAA,OAAO,CAACC,GAAR,CAAY4B,MAAZ;AACAX,IAAAA,IAAI,CAAC1D,EAAL,CAAQgG,UAAR,CAAmB3B,MAAnB,EAA2B,UAASJ,GAAT,EAAcnB,IAAd,EAAoB;AAC3C,UAAImB,GAAJ,EAAS;AACLzB,QAAAA,OAAO,CAACC,GAAR,CAAYwB,GAAZ,EAAiBA,GAAG,CAACyB,KAArB;AACH,OAFD,CAEE;AAFF,WAGK;AACD;;;;AAIAhC,UAAAA,IAAI,CAACrD,IAAL,CAAU4F,IAAV,CAAenD,IAAI,CAACoD,IAApB;;AACA,cAAIxC,IAAI,CAACnD,WAAL,IAAoB,IAAxB,EAA8B;AAC1BmD,YAAAA,IAAI,CAACyC,mBAAL;AACH;AACJ;AACJ,KAdD;AAeH;AAGA;;;;;AAGCA,EAAAA,mBAAmB,GAAG;AACpB,QAAIzC,IAAI,GAAG,IAAX;AACA,QAAI0C,SAAS,GAAG,EAAhB;AACA;;;;AAGA1C,IAAAA,IAAI,CAACrD,IAAL,CAAUgG,OAAV,CAAkB,CAACvD,IAAD,EAAOwD,KAAP,KAAiB;AAC/B,YAAMC,GAAG,GAAG;AACRL,QAAAA,IAAI,EAAEpD,IADE;AAER+C,QAAAA,UAAU,EAAE,EAAES;AAFN,OAAZ;AAIAF,MAAAA,SAAS,CAACH,IAAV,CAAeM,GAAf;AACH,KAND;AAQA,QAAIlC,MAAM,GAAG;AACTC,MAAAA,MAAM,EAAC,WADE;AACW;AACpBgB,MAAAA,GAAG,EAAE5B,IAAI,CAACjD,QAFD;AAEW;AACpBkF,MAAAA,QAAQ,EAAEjC,IAAI,CAAC/C,QAHN;AAGgB;AACzB6F,MAAAA,eAAe,EAAE;AACbC,QAAAA,KAAK,EAAEL;AADM;AAJR,KAAb;AASA1C,IAAAA,IAAI,CAAC1D,EAAL,CAAQ0G,uBAAR,CAAgCrC,MAAhC,EAAwC,UAASJ,GAAT,EAAcnB,IAAd,EAAoB;AACxD,UAAImB,GAAJ,EAAS;AACLzB,QAAAA,OAAO,CAACC,GAAR,CAAYwB,GAAZ,EAAiBA,GAAG,CAACyB,KAArB;AACH,OAFD,CAEE;AAFF,WAGK;AACDhC,UAAAA,IAAI,CAACiD,YAAL,CAAkB7D,IAAI,CAAC8D,QAAvB,EADC,CAED;;AACAlD,UAAAA,IAAI,CAACrD,IAAL,GAAY,EAAZ;AACAqD,UAAAA,IAAI,CAACpD,cAAL,GAAsB,EAAtB;AACAoD,UAAAA,IAAI,CAAC/C,QAAL,GAAgB,EAAhB;AACA+C,UAAAA,IAAI,CAACnD,WAAL,GAAmB,KAAnB,CANC,CAOH;AACD;;AACGgC,UAAAA,KAAK,CAAC,+CAAD,CAAL;AACH;AACJ,KAfD;AAgBH;;AAEDoE,EAAAA,YAAY,CAACE,SAAD,EAAW;AACrB,QAAI/D,IAAI,GAAC;AACHF,MAAAA,MAAM,EAAE,KAAK1D,KAAL,CAAW0D,MADhB;AAEHkE,MAAAA,MAAM,EAAE,KAAK7H,KAAL,CAAW8H,IAAX,CAAgBD,MAFrB;AAGHE,MAAAA,aAAa,EAAEH;AAHZ,KAAT,CADqB,CAMvB;AACA;;AACE7I,IAAAA,sBAAsB,CAAC,cAAD,EAAgB8E,IAAhB,CAAtB,CACCmE,IADD,CACMC,QAAQ,IAAI;AAChB,UAAIA,QAAQ,CAACpE,IAAT,CAAcqE,MAAd,KAAyB,SAA7B,EAAwC,CAEvC;AACF,KALD,EAMCC,KAND,CAMOnD,GAAG,IAAI;AACZzB,MAAAA,OAAO,CAACC,GAAR,CAAYwB,GAAZ;AACD,KARD;AASD;;AAEDxC,EAAAA,oBAAoB,GAAE;AAClBe,IAAAA,OAAO,CAACC,GAAR,CAAY,sBAAZ;AACA,SAAK5B,mBAAL,CAAyB0D,cAAzB;AACH;;AAECjD,EAAAA,SAAS,CAAC+F,QAAD,EAAWC,QAAX,EAAqB7I,MAArB,EAA6B;AACpC,SAAKA,MAAL,GAAcA,MAAd;AAAqB,QAAIiF,IAAI,GAAC,IAAT,CADe,CAExC;;AACG,QAAI6D,KAAJ,EAAUC,MAAV,CAHqC,CAKxC;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAG,KAAKvI,KAAL,CAAW8H,IAAX,CAAgBU,MAAhB,IAA0B,CAA7B,EAA+B;AACvB,WAAKrG,EAAL,GAAU,IAAI7D,cAAJ,CAAmB,KAAK0B,KAAL,CAAWyD,QAAX,CAAoBxD,KAApB,CAA0BwI,cAA7C,EACT7E,EADS,CACN,aADM,EACUV,GAAD,IAAS;AAC1B,cAAMwF,QAAQ,GAAG;AAAEvI,UAAAA,UAAU,EAAE,QAAd;AAAwBG,UAAAA,QAAQ,EAAE4C;AAAlC,SAAjB;AACAK,QAAAA,OAAO,CAACC,GAAR,CAAYN,GAAZ;AACA,aAAKpB,WAAL,GAAkBoB,GAAlB;AAGA,YAAI,CAACkF,QAAL,EAAeM,QAAQ,CAACtI,SAAT,GAAqB,EAArB;AACf,aAAKsD,QAAL,CAAcgF,QAAd;AAED,OAVS,EAWT9E,EAXS,CAWN,YAXM,EAWQV,GAAG,IAAG;AAEpB,aAAKtB,mBAAL,GAA2BlD,SAAS,CAAC,CAAC,KAAKoD,WAAN,EAAkBoB,GAAlB,CAAD,EAAyB;AACzD;AACDgB,UAAAA,IAAI,EAAE,OAFoD;AAG1DyE,UAAAA,QAAQ,EAAE,WAHgD;AAK1DC,UAAAA,YAAY,EAAElK,SAAS,CAACmK,mBALkC;AAO1D;AACAC,UAAAA,WAAW,EAAE,IAR6C;AAU1D;AACA;AACAC,UAAAA,SAAS,EAAE,MAZ+C;AAc1D;AACA;AACAC,UAAAA,eAAe,EAAE,UAASC,CAAT,EAAY;AAG/B,gBAAIC,SAAS,GAAG,EAAhB;AACA;;;;AAGAzE,YAAAA,IAAI,CAACpD,cAAL,CAAoB2F,IAApB,CAAyBiC,CAAzB;AACAC,YAAAA,SAAS,CAAClC,IAAV,CAAeiC,CAAf,EAR+B,CAYxB;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMP;;;AAGD;AACA;AACA;;AACC,gBAAIE,IAAI,GAAG1E,IAAI,CAAC2E,WAAL,CAAiBH,CAAC,CAACE,IAAnB,CAAX;AACA5F,YAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ,EAAoB2F,IAApB;AACD5F,YAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ,EAAiCiB,IAAI,CAACpD,cAAtC;;AAEC,gBAAIoD,IAAI,CAACpD,cAAL,CAAoBgI,MAApB,IAA8B,CAAlC,EAAqC;AACjC;AACK9F,cAAAA,OAAO,CAACC,GAAR,CAAY,sBAAZ;AAELiB,cAAAA,IAAI,CAACyB,gBAAL,CAAsB+C,CAAtB,EAAyBxE,IAAI,CAACjD,QAA9B;AACH,aALD,MAKO;AACH;;;;AAID+B,cAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ;AAECiB,cAAAA,IAAI,CAAClD,IAAL,GAAYkD,IAAI,CAAClD,IAAL,GAAY,CAAxB;AACAkD,cAAAA,IAAI,CAACkC,mBAAL,CAAyBsC,CAAzB,EAA4BxE,IAAI,CAAClD,IAAjC,EAAuCkD,IAAI,CAAC/C,QAA5C,EAAsD+C,IAAI,CAACjD,QAA3D,EAAqEiD,IAAI,CAAChF,UAA1E;AACH;AAEE,WA7EyD;AA+E1D;AACA6J,UAAAA,sBAAsB,EAAE,KAhFkC;AAkF1D;AACAC,UAAAA,WAAW,EAAE,UAASC,SAAT,EAAoB,CAAE,CAnFuB;AAqF1D;AACAC,UAAAA,aAAa,EAAE,MAtF2C;AAwF1D;AACA;AACAC,UAAAA,aAAa,EAAE,UAASC,MAAT,EAAiB;AAC5BpG,YAAAA,OAAO,CAACC,GAAR,CAAYmG,MAAZ;AACH,WA5FyD;AA8F1D;AACAC,UAAAA,YAAY,EAAE;AA/F4C,SAAzB,CAApC;AAkGF,aAAKlG,QAAL,CAAc;AAAEnD,UAAAA,OAAO,EAAE2C;AAAX,SAAd;AACD,OAhHS,EAiHTsC,KAjHS,CAiHH4C,QAjHG,EAiHO5I,MAjHP,CAAV;AAmHH,KApHL,MAoHS;AACD,WAAK2C,EAAL,GAAU,IAAI7D,cAAJ,CAAmB,KAAK0B,KAAL,CAAWyD,QAAX,CAAoBxD,KAApB,CAA0BwI,cAA7C,EACD7E,EADC,CACE,aADF,EACkBV,GAAD,IAAS;AAC1B,cAAMwF,QAAQ,GAAG;AAAEvI,UAAAA,UAAU,EAAE,QAAd;AAAwBG,UAAAA,QAAQ,EAAE4C;AAAlC,SAAjB;AACA,YAAI,CAACkF,QAAL,EAAeM,QAAQ,CAACtI,SAAT,GAAqB,EAArB;AACf,aAAKsD,QAAL,CAAcgF,QAAd;AACD,OALC,EAMD9E,EANC,CAME,YANF,EAMgBV,GAAG,IAAG;AACtB,aAAKQ,QAAL,CAAc;AAAEnD,UAAAA,OAAO,EAAE2C;AAAX,SAAd;AACD,OARC,EASDsC,KATC,CASK4C,QATL,EASe5I,MATf,CAAV;AAUH;AACJ;;AAEC4J,EAAAA,WAAW,CAACS,KAAD,EAAQ;AACjB,QAAIC,CAAC,GAAG,IAAR;AACA,QAAIC,KAAK,GAAG,CAAC,OAAD,EAAU,IAAV,EAAgB,IAAhB,EAAsB,IAAtB,EAA4B,IAA5B,CAAZ;AACA,QAAIF,KAAK,KAAK,CAAd,EAAiB,OAAO,SAAP;AACjB,QAAIG,CAAC,GAAGC,QAAQ,CAACC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAAC1G,GAAL,CAASqG,KAAT,IAAkBK,IAAI,CAAC1G,GAAL,CAASsG,CAAT,CAA7B,CAAD,EAA4C,EAA5C,CAAhB;AACA,WAAO,CAACD,KAAK,GAAGK,IAAI,CAACE,GAAL,CAASN,CAAT,EAAYE,CAAZ,CAAT,EAAyBK,WAAzB,CAAqC,CAArC,IAA0C,GAA1C,GAAgDN,KAAK,CAACC,CAAD,CAA5D;AACH;;AAECpH,EAAAA,UAAU,GAAG;AAAA,UACHvC,QADG,GACU,KAAKJ,KADf,CACHI,QADG;AAEXhC,IAAAA,MAAM,CAACiG,IAAP,CAAY,KAAZ,EAAmB;AAAEgG,MAAAA,EAAE,EAAEjK;AAAN,KAAnB;AACA,SAAKqD,QAAL,CAAc;AAAEtD,MAAAA,SAAS,EAAE;AAAb,KAAd;AACD;;AAEDsC,EAAAA,OAAO,CAAC6H,SAAD,EAAY;AACnB,QAAG,KAAKvK,KAAL,CAAW8H,IAAX,CAAgBU,MAAhB,IAA0B,CAA7B,EACE,KAAK5G,mBAAL,CAAyB8D,aAAzB;AACA,QAAItH,CAAC,CAACoM,UAAF,CAAa,KAAKrI,EAAL,CAAQwD,IAArB,CAAJ,EAAgC,KAAKxD,EAAL,CAAQwD,IAAR,CAAa4E,SAAb;AAChC,SAAKpI,EAAL,GAAU,EAAV;AACA,SAAK3C,MAAL,GAAc,IAAd;AACA,SAAKkE,QAAL,CAAc;AACZvD,MAAAA,UAAU,EAAE,EADA;AAEZG,MAAAA,QAAQ,EAAE,IAFE;AAGZC,MAAAA,OAAO,EAAE;AAHG,KAAd,EANiB,CAalB;AACD;;AACE,SAAKe,WAAL,GAAmB,IAAnB,CAfiB,CAgBrB;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACG;;AAEDnD,EAAAA,MAAM,GAAG;AAAA,wBACkE,KAAK8B,KADvE;AAAA,UACCC,QADD,eACCA,QADD;AAAA,UACWG,QADX,eACWA,QADX;AAAA,UACqBD,SADrB,eACqBA,SADrB;AAAA,UACgCD,UADhC,eACgCA,UADhC;AAAA,UAC4CG,QAD5C,eAC4CA,QAD5C;AAAA,UACsDC,OADtD,eACsDA,OADtD;AAEP,WACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE,oBAAC,MAAD,oBAAY,KAAKP,KAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OADF,EAEE,oBAAC,UAAD;AACE,MAAA,QAAQ,EAAEE,QADZ;AAEE,MAAA,SAAS,EAAE,KAAKkC,gBAFlB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAFF,EAOE,oBAAC,UAAD;AACE,MAAA,MAAM,EAAEjC,UADV;AAEE,MAAA,QAAQ,EAAEG,QAFZ;AAGE,MAAA,OAAO,EAAEC,OAHX;AAIE,MAAA,MAAM,EAAE,KAAKf,MAJf;AAKE,MAAA,WAAW,EAAE,KAAK2C,EAAL,CAAQsI,WALvB;AAME,MAAA,OAAO,EAAE,KAAKhI,cANhB;AAOE,MAAA,IAAI,EAAE,KAAKzC,KAAL,CAAW8H,IAPnB;AAQE,MAAA,oBAAoB,EAAE,KAAKvF,sBAR7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAPF,EAiBE,oBAAC,SAAD;AACE,MAAA,MAAM,EAAEnC,SADV;AAEE,MAAA,SAAS,EAAE,KAAKgC,gBAFlB;AAGE,MAAA,UAAU,EAAE,KAAKO,iBAHnB;AAIE,MAAA,QAAQ,EAAEtC,QAJZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAjBF,CADF;AA0BD;;AAhtByB;;AAotB5B,MAAMqK,eAAe,GAAGzK,KAAK,IAAI;AAC/B,SAAO;AACL6H,IAAAA,IAAI,EAAE7H,KAAK,CAAC0K,IAAN,CAAWC;AADZ,GAAP;AAGD,CAJD;;AAMA,eAAehM,OAAO,CACpB8L,eADoB,EAEpB,IAFoB,CAAP,CAGb5K,GAHa,CAAf","sourcesContent":["import React, { Component } from 'react';\r\nimport { render } from 'react-dom';\r\nimport _ from 'lodash';\r\nimport socket from './socket';\r\nimport PeerConnection from './PeerConnection';\r\nimport MainWindow from './MainWindow';\r\nimport CallWindow from './CallWindow';\r\nimport CallModal from './CallModal';\r\n//import { captureUserMedia, S3Upload } from './AppUtils';\r\nimport RecordRTC from 'recordrtc';\r\nimport { Modal } from 'react-bootstrap';\r\nimport { connect } from 'react-redux';\r\n//import MultiStreamsMixer from 'multistreamsmixer';\r\nimport $ from 'jquery'; \r\nimport Header from '../header/header';\r\nimport theRapidHireApiService from '../../common/core/api/apiService';\r\n//import {MediaStreamRecorder} from '/MediaStreamRecorder.js';\r\n//import MediaStreamRecorder from '../../../node_modules/msr/MediaStreamRecorder.js';\r\nconst hasGetUserMedia = !!(navigator.getUserMedia || navigator.webkitGetUserMedia ||\r\n                        navigator.mozGetUserMedia || navigator.msGetUserMedia);\r\n                       \r\n                        //loadScript('https://sdk.amazonaws.com/js/aws-sdk-2.2.32.min.js')\r\n                      \r\nvar AWS = require('aws-sdk');\r\n//var multiStreamRecorder;\r\nconst config = {\r\n  bucketName: 'ankurself',\r\n  dirName: 'photos', /* optional */\r\n  region: 'ap-south-1', // Put your aws region here\r\n  accessKeyId: 'AKIAJHHM3PCJ25PK6OWQ',\r\n  secretAccessKey: 'fTo0CpSivV7OWo2TrFGNUaA5E6ST1pB9Pwnsp5HB'\r\n}\r\n\r\nclass App extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      clientId: '',\r\n      callWindow: '',\r\n      callModal: '',\r\n      callFrom: '',\r\n      localSrc: null,\r\n      peerSrc: null,\r\n      recordVideo: null     \r\n    };\r\n    var wRegion = \"ap-south-1\";\r\n    var poolid = 'ap-south-1:5075a328-2598-4e55-ba57-d4b60ed9548c';\r\n    var s3bucketName = \"ankurself\";\r\n    var audioPath = \"/audio-files\";\r\n    var s3bucketName = \"ankurself\";\r\n    var audioPath = \"/audio-files\";\r\n    var audioStoreWithBucket=s3bucketName+audioPath;\r\n    //AudioStream = new AudioStream(wRegion,poolid,s3bucketName+audioPath)\r\n\r\n    this.region = \"ap-south-1\"; //s3 region\r\n    this.IdentityPoolId = 'ap-south-1:5075a328-2598-4e55-ba57-d4b60ed9548c'; //identity pool id\r\n    this.bucketName = audioStoreWithBucket; //audio file store\r\n    this.s3=''; //variable defination for s3\r\n    this.dateinfo = new Date();\r\n    this.timestampData = this.dateinfo.getTime(); //timestamp used for file uniqueness\r\n    this.etag = []; // etag is used to save the parts of the single upload file\r\n    this.recordedChunks = []; //empty Array\r\n    this.booleanStop = false; // this is for final multipart complete\r\n    this.incr = 0; // multipart requires incremetal so that they can merge all parts by ascending order\r\n    this.filename = this.timestampData.toString() + \".webm\"; //unique filename\r\n    this.uploadId = \"\"; // upload id is required in multipart\r\n    this.recorder=''; //initializing recorder variable\r\n    this.multiStreamRecorder='';\r\n    this.player='';\r\n    this.localSource='';\r\n    //To use microphone it shud be {audio: true}\r\n    this.audioConstraints = {\r\n        audio: true,\r\n        video: true,\r\n        audio: {echoCancellation:true}\r\n    };\r\n    this.pc = {};\r\n    this.config = null;\r\n    this.startCallHandler = this.startCall.bind(this);\r\n    this.startCallByInterviewer = this.startCallInterviewer.bind(this);\r\n    \r\n    this.endCallHandler = this.endCall.bind(this);\r\n    this.rejectCallHandler = this.rejectCall.bind(this);\r\n    this.requestUserMedia = this.requestUserMedia.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    var script = document.createElement(\"script\");\r\n\r\n    script.src = \"../dist/js/app.min.js\";\r\n    script.async = true;\r\n\r\n    document.body.appendChild(script);\r\n\r\n \r\n    if(!hasGetUserMedia) {\r\n      alert(\"Your browser cannot stream from your webcam. Please switch to Chrome or Firefox.\");\r\n      return;\r\n    }   \r\n    \r\n    console.log(this.props.location.state);\r\n\r\n    this.setState({slotId: this.props.location.state.slotId});\r\n\r\n\r\n    socket\r\n      .on('init', data => this.setState({ clientId: this.props.location.state.videoKeySelf })) // to another user's id\r\n      .on('request', data => {\r\n        console.log(data);\r\n       this.setState({ callModal: 'active', callFrom: data.from })\r\n      })\r\n      .on('call', (data) => {\r\n        if (data.sdp) {\r\n          this.pc.setRemoteDescription(data.sdp);\r\n          if (data.sdp.type === 'offer') this.pc.createAnswer();\r\n        } else this.pc.addIceCandidate(data.candidate);\r\n      })\r\n      .on('end', this.endCall.bind(this, false))\r\n      .emit('init',this.props.location.state.videoKeySelf);    // self id kept\r\n    }\r\n\r\n    componentWillMount(){\r\n     // this.requestUserMedia();\r\n      this.audioStreamInitialize();\r\n    }\r\n  \r\n    requestUserMedia() {      \r\n      console.log('requestUserMedia')\r\n    //   captureUserMedia((stream) => {\r\n    //     this.setState({ localSrc: stream});\r\n    //     this.setState({ peerSrc : stream});\r\n    //     console.log('setting state', this.state)\r\n    //   });\r\n    }\r\n\r\n    audioStreamInitialize() {\r\n      /*\r\n          Creates a new credentials object, which will allow us to communicate with the aws services.\r\n      */\r\n      var self = this;\r\n      AWS.config.update({\r\n           region: \"ap-south-1\",\r\n               credentials: new AWS.CognitoIdentityCredentials({\r\n                  IdentityPoolId: 'ap-south-1:5075a328-2598-4e55-ba57-d4b60ed9548c',\r\n                  RoleArn: 'arn:aws:iam::923146643705:role/Cognito_TestPoolUnauth_Role',\r\n                  AccountId: '923146643705' // your AWS account ID\r\n  \r\n               })\r\n          });\r\n  \r\n              AWS.config.credentials.get(function (err) {\r\n      if (err) console.log(err);\r\n      else console.log(AWS.config.credentials);\r\n  });\r\n      \r\n      self.s3 = new AWS.S3({logger:console,\r\n  //         AWSAccessKeyId=AKIAJRQYW4X2EL2WE6UQ\r\n  // AWSSecretKey=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\r\n       apiVersion: '2006-03-01',\r\n          params: {Bucket: 'ankurself'}\r\n  \r\n  \r\n  })\r\n      /*\r\n          Feature detecting is a simple check for the existence of \"navigator.mediaDevices.getUserMedia\"\r\n          To use the microphone. we need to request permission.\r\n          The parameter to getUserMedia() is an object specifying the details and requirements for each type of media you want to access.\r\n          To use microphone it shud be {audio: true}\r\n      */\r\n    //   navigator.mediaDevices.getUserMedia(self.audioConstraints)\r\n    //       .then(function(stream) {\r\n              \r\n    //           /*\r\n    //               once we accept the prompt for the audio stream from user's mic we enable the record button.\r\n    //           */\r\n    //         //  $(\"#record_q1\").removeAttr(\"disabled\");\r\n    //           /*\r\n    //               Creates a new MediaRecorder object, given a MediaStream to record.\r\n    //           */\r\n    //           self.recorder = new MediaRecorder(stream);\r\n    //                           self.setState({videosrc:stream});                               \r\n            \r\n    //           self.recorder.addEventListener('dataavailable', function(e) {\r\n    //               var normalArr = [];\r\n    //               /*\r\n    //                   Here we push the stream data to an array for future use.\r\n    //               */\r\n    //               self.recordedChunks.push(e.data);\r\n    //               normalArr.push(e.data);\r\n  \r\n    //               /*\r\n    //                   here we create a blob from the stream data that we have received.\r\n    //               */\r\n    //               var blob = new Blob(normalArr, {\r\n    //                   type: 'video/webm'\r\n    //               });\r\n                           \r\n    //               /*\r\n    //                   if the length of recordedChunks is 1 then it means its the 1st part of our data.\r\n    //                   So we createMultipartUpload which will return an upload id.\r\n    //                   Upload id is used to upload the other parts of the stream\r\n    //                   else.\r\n    //                   It Uploads a part in a multipart upload.\r\n    //               */\r\n    //               if (self.recordedChunks.length == 1) {\r\n    //                        console.log(blob.size);\r\n  \r\n  \r\n    //                   self.startMultiUpload(blob, self.filename)\r\n    //               } else {\r\n    //                   /*\r\n    //                       self.incr is basically a part number.\r\n    //                       Part number of part being uploaded. This is a positive integer between 1 and 10,000.\r\n    //                   */\r\n    //                   self.incr = self.incr + 1\r\n    //                   self.continueMultiUpload(blob, self.incr, self.uploadId, self.filename, self.bucketName);\r\n    //               }\r\n    //           })\r\n    //       });\r\n\r\n     //  this.startRecording(isCaller);\r\n//    navigator.mediaDevices.getUserMedia({\r\n//     video: true,\r\n//     audio: true\r\n// }).then(async function(stream) {\r\n   \r\n//     self.state.recordVideo = RecordRTC(stream, {     \r\n  \r\n\r\n//     // disable logs\r\n//     disableLogs: true,\r\n   \r\n//     // disable logs\r\n//     disableLogs: true,\r\n \r\n//     // get intervals based blobs\r\n//     // value in milliseconds\r\n//     timeSlice: 150000,\r\n//     ondataavailable: function(e) {\r\n//     console.log('ondataavailable -- ');\r\n\r\n//       var normalArr = [];\r\n//       /*\r\n//           Here we push the stream data to an array for future use.\r\n//       */\r\n//       self.recordedChunks.push(e.data);\r\n//       normalArr.push(e.data);\r\n\r\n//       /*\r\n//           here we create a blob from the stream data that we have received.\r\n//       */\r\n//       var blob = new Blob(normalArr, {\r\n//           type: 'video/webm'\r\n//       });                   \r\n//   //    let size = bytesToSize(recorder.getBlob().size);\r\n\r\n//       if (self.recordedChunks.length == 1) {\r\n//                console.log(blob.size);\r\n\r\n\r\n//           self.startMultiUpload(blob, self.filename)\r\n//       } else {\r\n//           /*\r\n//               self.incr is basically a part number.\r\n//               Part number of part being uploaded. This is a positive integer between 1 and 10,000.\r\n//           */\r\n//           self.incr = self.incr + 1\r\n//           self.continueMultiUpload(blob, self.incr, self.uploadId, self.filename, self.bucketName);\r\n//       }}\r\n//   });      \r\n\r\n  \r\n//});\r\n  }\r\n\r\n  startRecording(id) {\r\n    var self = this; \r\n    \r\n    this.recorder.start(50000);\r\n    console.log('recprdomg');\r\n    this.setState({showVideo:true});\r\n}\r\n\r\nstopRecording(id) {\r\n    var self = this;\r\n    self.recorder.stop();\r\n    self.booleanStop = true;\r\n    //disable self\r\n   \r\n  //  self.disableAllButton()\r\n  //  $(\"#stop_q1\").attr(\"disabled\", \"disabled\");\r\n    // add loader\r\n  //  self.setLoader();\r\n    this.setState({showVideo:false});\r\n}\r\n\r\npauseRecording(id) {\r\n    var self = this;\r\n    self.recorder.pause();\r\n   $(\"#pause_q1\").addClass(\"hide\");\r\n    $(\"#resume_q1\").removeClass(\"hide\");\r\n}\r\n \r\n\r\nresumeRecording(id) {\r\n    var self = this;\r\n    self.recorder.resume();\r\n   $(\"#resume_q1\").addClass(\"hide\");\r\n    $(\"#pause_q1\").removeClass(\"hide\");\r\n}\r\n\r\nstartMultiUpload(blob, filename) {\r\n    var self = this;\r\n    var audioBlob = blob;\r\n    var params = {\r\n     \r\n        Bucket: 'ankurself',\r\n        Key: filename,\r\n        ContentType: 'video/webm',\r\n        ACL: 'public-read'           \r\n    };\r\n    self.s3.createMultipartUpload(params, function(err, data) {\r\n        if (err) {\r\n            console.log(err, err.stack); // an error occurred\r\n        } else {\r\n            self.uploadId = data.UploadId\r\n            self.incr = 1;\r\n            self.continueMultiUpload(audioBlob, self.incr, self.uploadId, self.filename, self.bucketName);\r\n        }\r\n    });\r\n}\r\n \r\n\r\n /*\r\n       Uploads a part in a multipart upload.\r\n       The following code uploads part of a multipart upload.\r\n       it specifies a file name for the part data. The Upload ID is same that is returned by the initiate multipart upload.\r\n   */\r\n  continueMultiUpload(audioBlob, PartNumber, uploadId, key, bucketName) {\r\n    var self = this;\r\n \r\n \r\n \r\n    var params = {\r\n        Body: audioBlob,\r\n        Bucket: 'ankurself',\r\n        Key: key,\r\n        PartNumber: PartNumber,\r\n        UploadId: uploadId\r\n    };\r\n    console.log(params);\r\n    self.s3.uploadPart(params, function(err, data) {\r\n        if (err) {\r\n            console.log(err, err.stack)\r\n        } // an error occurred\r\n        else {\r\n            /*\r\n                Once the part of data is uploaded we get an Entity tag for the uploaded object(ETag).\r\n                which is used later when we complete our multipart upload.\r\n            */\r\n            self.etag.push(data.ETag);\r\n            if (self.booleanStop == true) {\r\n                self.completeMultiUpload();\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n\r\n /*\r\n       Completes a multipart upload by assembling previously uploaded parts.\r\n   */\r\n  completeMultiUpload() {\r\n    var self = this;\r\n    var outputTag = [];\r\n    /*\r\n        here we are constructing the Etag data in the required format.\r\n    */\r\n    self.etag.forEach((data, index) => {\r\n        const obj = {\r\n            ETag: data,\r\n            PartNumber: ++index\r\n        };\r\n        outputTag.push(obj);\r\n    });\r\n\r\n    var params = {\r\n        Bucket:'ankurself', // required\r\n        Key: self.filename, // required\r\n        UploadId: self.uploadId, // required\r\n        MultipartUpload: {\r\n            Parts: outputTag\r\n        }\r\n    };\r\n\r\n    self.s3.completeMultipartUpload(params, function(err, data) {\r\n        if (err) {\r\n            console.log(err, err.stack)\r\n        } // an error occurred\r\n        else {\r\n            self.saveVideoURL(data.Location);\r\n            // initialize variable back to normal\r\n            self.etag = [];\r\n            self.recordedChunks = [];\r\n            self.uploadId = \"\";\r\n            self.booleanStop = false;\r\n          //  self.disableAllButton();\r\n         //   self.removeLoader();\r\n            alert(\"we have successfully saved the questionaire..\");\r\n        }\r\n    });\r\n}\r\n\r\nsaveVideoURL(videoLink){\r\n  let data={\r\n        slotId: this.state.slotId ,\r\n        userId: this.props.user.userId,\r\n        videoChatLink: videoLink\r\n  };\r\n//facebook app secret --   appID --1928279157274431\r\n//8cfe05bdd0ecbdfa3d51460f2d9b21ae\r\n  theRapidHireApiService('saveChatLink',data)\r\n  .then(response => {     \r\n    if (response.data.status === 'Success') {\r\n      \r\n    }\r\n  })\r\n  .catch(err => {\r\n    console.log(err);\r\n  });\r\n}\r\n\r\nstartCallInterviewer(){\r\n    console.log('startCallInterviewer');\r\n    this.multiStreamRecorder.startRecording();\r\n}\r\n\r\n  startCall(isCaller, friendID, config) {\r\n    this.config = config;let self=this;\r\n// try array format to record parallely ---    \r\n   let local,remote;\r\n \r\n//    if(this.props.user.roleId == 2){\r\n//     this.pc = new PeerConnection(this.props.location.state.videoKeyClient)\r\n//       .on('localStream', (src) => {\r\n//         const newState = { callWindow: 'active', localSrc: src };        \r\n//         if (!isCaller) newState.callModal = '';\r\n    \r\n//         this.multiStreamRecorder = new RecordRTC([src]);\r\n       \r\n//         this.multiStreamRecorder.stream = src;\r\n//     //    multiStreamRecorder.mimeType = 'audio/webm';\r\n//     this.multiStreamRecorder.mimeType = 'video/webm';\r\n//     this.multiStreamRecorder.previewStream = function(stream) {\r\n//       //    video.srcObject = stream;\r\n//         //  video.play();\r\n//       };\r\n//       this.multiStreamRecorder.ondataavailable = function(e) {\r\n//          //   appendLink(blob);\r\n  \r\n//          var normalArr = [];\r\n//          /*\r\n//              Here we push the stream data to an array for future use.\r\n//          */\r\n//          self.recordedChunks.push(e);\r\n//          normalArr.push(e);\r\n   \r\n\r\n\r\n//                 // //   appendLink(blob);\r\n//                 // let MB = 5 * 1024 * 1024\r\n//                 // let size = self.bytesToSize(e.size);\r\n//                 // console.log(e.size >= MB);\r\n\r\n//                 // /*\r\n//                 //     Here we push the stream data to an array for future use.\r\n//                 // */\r\n//                 // vardata.push(e);\r\n//                 // // normalArr.push(e);\r\n//                 // let checkSize=0;\r\n//                 // vardata.forEach(function(data){\r\n//                 //     checkSize = checkSize + data.size;\r\n//                 // })\r\n//                 // console.log('checkSize -- ',checkSize);\r\n//                 // if(checkSize <= MB )\r\n//                 // return false;\r\n//                 // self.recordedChunks.push = [];\r\n\r\n\r\n\r\n\r\n\r\n//          /*\r\n//              here we create a blob from the stream data that we have received.\r\n//          */\r\n//          var blob = new Blob(normalArr, {\r\n//              type: 'video/webm'\r\n//          });                   \r\n//          let size = self.bytesToSize(e.size);\r\n//          console.log('size ',size);\r\n//         console.log('recordedChunks -- ',self.recordedChunks);\r\n        \r\n//          if (self.recordedChunks.length == 1) {\r\n//                   console.log(blob.size);\r\n//                   console.log('startMultiUpload -- ',);\r\n   \r\n//              self.startMultiUpload(e, self.filename)\r\n//          } else {\r\n//              /*\r\n//                  self.incr is basically a part number.\r\n//                  Part number of part being uploaded. This is a positive integer between 1 and 10,000.\r\n//              */\r\n//             console.log('continueMultiUpload -- ',);\r\n   \r\n//              self.incr = self.incr + 1\r\n//              self.continueMultiUpload(e, self.incr, self.uploadId, self.filename, self.bucketName);\r\n//          }\r\n//         }; \r\n       \r\n//         local= src;\r\n//         this.setState(newState);\r\n        \r\n//       })\r\n//       .on('peerStream', src =>{\r\n//         this.multiStreamRecorder.addStream( src );\r\n//         this.setState({ peerSrc: src });\r\n      \r\n//       })\r\n//       .start(isCaller, config);\r\n//     }else{\r\n//         this.pc = new PeerConnection(this.props.location.state.videoKeyClient)\r\n//         .on('localStream', (src) => {\r\n//           const newState = { callWindow: 'active', localSrc: src };        \r\n//           if (!isCaller) newState.callModal = '';        \r\n//           this.setState(newState);        \r\n//         })\r\n//         .on('peerStream', src =>{       \r\n//           this.setState({ peerSrc: src });        \r\n//         })\r\n//         .start(isCaller, config);\r\n//     }\r\n\r\nif(this.props.user.roleId == 2){\r\n        this.pc = new PeerConnection(this.props.location.state.videoKeyClient)\r\n        .on('localStream', (src) => {\r\n          const newState = { callWindow: 'active', localSrc: src }; \r\n          console.log(src);\r\n          this.localSource= src;\r\n\r\n         \r\n          if (!isCaller) newState.callModal = '';        \r\n          this.setState(newState);   \r\n             \r\n        })\r\n        .on('peerStream', src =>{   \r\n           \r\n            this.multiStreamRecorder = RecordRTC([this.localSource,src], {\r\n                // audio, video, canvas, gif\r\n               type: 'video',   \r\n               mimeType: 'video/mp4', \r\n             \r\n               recorderType: RecordRTC.MultiStreamRecorder,\r\n           \r\n               // disable logs\r\n               disableLogs: true,\r\n           \r\n               // get intervals based blobs\r\n               // value in milliseconds\r\n               timeSlice: 180000,\r\n           \r\n               // requires timeSlice above\r\n               // returns blob via callback function\r\n               ondataavailable: function(e) {\r\n    \r\n    \r\n             var normalArr = [];\r\n             /*\r\n                 Here we push the stream data to an array for future use.\r\n             */\r\n             self.recordedChunks.push(e);\r\n             normalArr.push(e);\r\n       \r\n    \r\n    \r\n                    // //   appendLink(blob);\r\n                    // let MB = 5 * 1024 * 1024\r\n                    // let size = self.bytesToSize(e.size);\r\n                    // console.log(e.size >= MB);\r\n    \r\n                    // /*\r\n                    //     Here we push the stream data to an array for future use.\r\n                    // */\r\n                    // vardata.push(e);\r\n                    // // normalArr.push(e);\r\n                    // let checkSize=0;\r\n                    // vardata.forEach(function(data){\r\n                    //     checkSize = checkSize + data.size;\r\n                    // })\r\n                    // console.log('checkSize -- ',checkSize);\r\n                    // if(checkSize <= MB )\r\n                    // return false;\r\n                    // self.recordedChunks.push = [];\r\n    \r\n    \r\n    \r\n    \r\n    \r\n             /*\r\n                 here we create a blob from the stream data that we have received.\r\n             */\r\n            //  var blob = new Blob(normalArr, {\r\n            //      type: 'video/webm'\r\n            //  });                   \r\n             let size = self.bytesToSize(e.size);\r\n             console.log('size ',size);\r\n            console.log('recordedChunks -- ',self.recordedChunks);\r\n            \r\n             if (self.recordedChunks.length == 1) {\r\n                 //     console.log(blob.size);\r\n                      console.log('startMultiUpload -- ',);\r\n       \r\n                 self.startMultiUpload(e, self.filename)\r\n             } else {\r\n                 /*\r\n                     self.incr is basically a part number.\r\n                     Part number of part being uploaded. This is a positive integer between 1 and 10,000.\r\n                 */\r\n                console.log('continueMultiUpload -- ',);\r\n       \r\n                 self.incr = self.incr + 1\r\n                 self.continueMultiUpload(e, self.incr, self.uploadId, self.filename, self.bucketName);\r\n             }\r\n                 \r\n               },\r\n           \r\n               // auto stop recording if camera stops\r\n               checkForInactiveTracks: false,\r\n           \r\n               // requires timeSlice above\r\n               onTimeStamp: function(timestamp) {},\r\n           \r\n               // both for audio and video tracks\r\n               bitsPerSecond: 128000,       \r\n           \r\n               // if you are recording multiple streams into single file\r\n               // this helps you see what is being recorded\r\n               previewStream: function(stream) {\r\n                   console.log(stream);\r\n               },\r\n           \r\n               // used by MultiStreamRecorder - to access HTMLCanvasElement\r\n               elementClass: 'multi-streams-mixer'\r\n           });\r\n    \r\n          this.setState({ peerSrc: src });        \r\n        })\r\n        .start(isCaller, config);\r\n\r\n    }else{\r\n        this.pc = new PeerConnection(this.props.location.state.videoKeyClient)\r\n                .on('localStream', (src) => {\r\n                  const newState = { callWindow: 'active', localSrc: src };        \r\n                  if (!isCaller) newState.callModal = '';        \r\n                  this.setState(newState);        \r\n                })\r\n                .on('peerStream', src =>{       \r\n                  this.setState({ peerSrc: src });        \r\n                })\r\n                .start(isCaller, config);\r\n    }\r\n}\r\n\r\n  bytesToSize(bytes) {\r\n    var k = 1000;\r\n    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\r\n    if (bytes === 0) return '0 Bytes';\r\n    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(k)), 10);\r\n    return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];\r\n}\r\n\r\n  rejectCall() {\r\n    const { callFrom } = this.state;\r\n    socket.emit('end', { to: callFrom });\r\n    this.setState({ callModal: '' });\r\n  }\r\n\r\n  endCall(isStarter) {\r\n  if(this.props.user.roleId == 2)\r\n    this.multiStreamRecorder.stopRecording();\r\n    if (_.isFunction(this.pc.stop)) this.pc.stop(isStarter);\r\n    this.pc = {};\r\n    this.config = null;\r\n    this.setState({\r\n      callWindow: '',\r\n      localSrc: null,\r\n      peerSrc: null\r\n    });\r\n\r\n  \r\n   // this.stopRecording(1);\r\n  //  this.state.recordVideo.stopRecording();\r\n    this.booleanStop = true;\r\n//     this.state.recordVideo.stopRecording(() => {\r\n//       let params = {\r\n//         type: 'video/webm',\r\n//         data: this.state.recordVideo.blob,\r\n//         id: Math.floor(Math.random()*90000) + 10000\r\n//       }\r\n\r\n//  console.log('enter then statement')\r\n//   //    this.setState({ uploading: true });\r\n\r\n//       S3Upload(params)\r\n//       .then((success) => {\r\n//         console.log('enter then statement')\r\n//         if(success) {\r\n//           console.log(success)\r\n//      //     this.setState({ uploadSuccess: true, uploading: false });\r\n//         }\r\n//       }, (error) => {\r\n//         alert(error, 'error occurred. check your aws settings and try again.')\r\n//       })\r\n//     });\r\n  }\r\n\r\n  render() {\r\n    const { clientId, callFrom, callModal, callWindow, localSrc, peerSrc } = this.state;\r\n    return (\r\n      <div>\r\n        <Header {...this.props} />      \r\n        <MainWindow\r\n          clientId={clientId}\r\n          startCall={this.startCallHandler}\r\n        />\r\n\r\n        <CallWindow\r\n          status={callWindow}\r\n          localSrc={localSrc}\r\n          peerSrc={peerSrc}\r\n          config={this.config}\r\n          mediaDevice={this.pc.mediaDevice}\r\n          endCall={this.endCallHandler}\r\n          user={this.props.user}\r\n          startCallInterviewer={this.startCallByInterviewer}\r\n        />\r\n        <CallModal\r\n          status={callModal}\r\n          startCall={this.startCallHandler}\r\n          rejectCall={this.rejectCallHandler}\r\n          callFrom={callFrom}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n\r\nconst mapStateToProps = state => {\r\n  return {\r\n    user: state.User.userData    \r\n  };\r\n};\r\n\r\nexport default connect(\r\n  mapStateToProps,\r\n  null\r\n)(App);\r\n"]},"metadata":{},"sourceType":"module"}